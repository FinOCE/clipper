import {
  AttachmentBuilder,
  ChannelType,
  Client,
  EmbedBuilder,
  Guild,
  Message,
  TextBasedChannel,
  User
} from "discord.js"
import { CanvasRenderingContext2D, createCanvas, loadImage } from "canvas"
import moment from "moment"
import { Color, headerGuildImageText, headerText } from "./styles"

/**
 * Generate a screenshot of a message and then DM it to the specified user.
 * @param user The user to send the screenshot to
 * @param message The message to take a screenshot of
 */
export default async function bookmark(
  client: Client<true>,
  user: User,
  guild: Guild | null,
  channel: TextBasedChannel | null,
  message: Message
) {
  // Generate image
  const buffer = await generateImage(guild, channel, message)
  const attachment = new AttachmentBuilder(buffer, {
    name: `${message.author.username}-${message.createdTimestamp}.png`
  })
  const embed = new EmbedBuilder()
    .setTitle("Message saved!")
    .setImage(`attachment://${attachment.name}`)
    .setFooter({
      iconURL: client.user.displayAvatarURL({ extension: "jpg" }),
      text: `Generated by ${client.user.displayName} - https://clipper.5f.au`
    })

  // DM screenshot to user
  channel?.send({ embeds: [embed], files: [attachment] }) // Just for testing, replace with below once working
  // await user
  //   .createDM()
  //   .then(dmChannel => dmChannel.send({ embeds: [embed], files: [attachment] }))
  //   .catch(err => console.error(err))
}

async function generateImage(guild: Guild | null, channel: TextBasedChannel | null, message: Message) {
  const canvas = createCanvas(1500, 1000)
  const ctx = canvas.getContext("2d")

  const padding = 50
  const imageSize = 130
  const headerHeight = 100

  // Background
  ctx.fillStyle = Color.DiscordGrey
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  // Guild/channel header
  if (guild && channel && channel.type == ChannelType.GuildText) {
    const guildImageSize = 80
    const guildImagePadding = (headerHeight - guildImageSize) / 2

    headerText(ctx)
    const guildNameWidth = ctx.measureText(guild.name).width
    const channelNameWidth = ctx.measureText(`#${channel.name}`).width

    const headerWidth = canvas.width
    const headerContentWidth = guildImageSize + guildImagePadding + guildNameWidth + padding + channelNameWidth
    const headerPadding = (headerWidth - headerContentWidth) / 2

    // Header background
    ctx.fillStyle = Color.DiscordGreyDark
    ctx.fillRect(0, 0, canvas.width, headerHeight)

    // Header guild image

    ctx.beginPath()
    ctx.arc(
      headerPadding + guildImageSize / 2,
      guildImagePadding + guildImageSize / 2,
      guildImageSize / 2,
      0,
      Math.PI * 2,
      true
    )
    ctx.closePath()
    ctx.save()
    ctx.clip()

    ctx.fillStyle = Color.DiscordGreyDarker
    ctx.fillRect(headerPadding, guildImagePadding, guildImageSize, guildImageSize)

    headerGuildImageText(ctx)
    ctx.fillText(
      guild.name.charAt(0).toUpperCase(),
      headerPadding + guildImageSize / 2,
      guildImagePadding + guildImageSize / 2
    )

    const guildIcon = guild.iconURL({ extension: "jpg" })
    if (guildIcon) {
      const image = await loadImage(guildIcon)
      ctx.drawImage(image, headerPadding, guildImagePadding, guildImageSize, guildImageSize)
    }

    ctx.restore()

    // Header text
    headerText(ctx)
    ctx.fillText(guild.name, headerPadding + guildImageSize + guildImagePadding, headerHeight / 2)
    headerText(ctx, true)
    ctx.fillText(
      `#${channel.name}`,
      headerPadding + guildImageSize + guildImagePadding + guildNameWidth + padding,
      headerHeight / 2
    )
  }

  // Avatar
  ctx.beginPath()
  ctx.arc(padding + imageSize / 2, headerHeight + padding + imageSize / 2, imageSize / 2, 0, Math.PI * 2, true)
  ctx.closePath()
  ctx.save()
  ctx.clip()

  const image = await loadImage(message.author.displayAvatarURL({ extension: "jpg" }))
  ctx.drawImage(image, padding, headerHeight + padding, imageSize, imageSize)

  ctx.restore()

  // Username
  ctx.font = "40px 'gg sans'"
  ctx.fillStyle = message.member ? message.member.displayHexColor : Color.White
  ctx.textBaseline = "top"
  ctx.textAlign = "left"
  ctx.fillText(message.author.displayName, padding + imageSize + padding, headerHeight + padding)

  const usernameWidth = ctx.measureText(message.author.displayName).width
  const usernamePadding = 25

  // Date
  ctx.font = "35px 'gg sans'"
  ctx.fillStyle = Color.LightGrey
  ctx.fillText(
    moment(message.createdAt).format("DD/MM/YYYY HH:mm"),
    padding + imageSize + padding + usernameWidth + usernamePadding,
    headerHeight + padding + 5
  )

  // Text content
  ctx.font = "40px 'gg sans'"
  ctx.fillStyle = Color.White

  separateMessageContent(message.content, ctx, canvas.width - padding * 3 - imageSize).map((line, index) => {
    ctx.fillText(line, padding + imageSize + padding, headerHeight + padding + 60 + index * 60)
  })

  // TODO: Little un-obtrusive watermark at the bottom?

  return canvas.toBuffer("image/jpeg", { quality: 1 })
}

function separateMessageContent(content: string, ctx: CanvasRenderingContext2D, maxWidth: number) {
  const words = content.split(" ")
  const lines: string[] = []

  let currentLine = ""
  for (const word of words) {
    if (ctx.measureText(currentLine + word).width >= maxWidth) {
      lines.push(currentLine)
      currentLine = word + " "
    } else {
      currentLine += word + " "
    }
  }
  lines.push(currentLine)
  return lines
}

// Ideas:
// - Allow screenshotting to include the message being replied to
// - Allow screenshotting to include the recent messages prior to it (what amount?)
