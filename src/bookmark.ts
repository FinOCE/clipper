import {
  AttachmentBuilder,
  ChannelType,
  Client,
  EmbedBuilder,
  Guild,
  Message,
  TextBasedChannel,
  User
} from "discord.js"
import { CanvasRenderingContext2D, createCanvas, loadImage } from "canvas"
import moment from "moment"
import {
  Color,
  headerGuildImageText,
  headerText,
  messageContentText,
  messageDateText,
  replyContentText,
  replyUsernameText,
  usernameText
} from "./styles"

/**
 * Generate a screenshot of a message and then DM it to the specified user.
 * @param user The user to send the screenshot to
 * @param message The message to take a screenshot of
 */
export default async function bookmark(
  client: Client<true>,
  user: User,
  guild: Guild | null,
  channel: TextBasedChannel | null,
  message: Message,
  reply: Message | null
) {
  // Generate image
  const buffer = await generateImage(guild, channel, message, reply)
  const attachment = new AttachmentBuilder(buffer, {
    name: `${message.author.username}-${message.createdTimestamp}.png`
  })
  const embed = new EmbedBuilder()
    .setTitle("Message saved!")
    .setColor(Color.Blurple)
    .setImage(`attachment://${attachment.name}`)
    .setFooter({
      iconURL: client.user.displayAvatarURL({ extension: "jpg" }),
      text: `Generated by ${client.user.displayName} - https://clipper.5f.au`
    })

  // DM screenshot to user
  channel?.send({ embeds: [embed], files: [attachment] }) // Just for testing, replace with below once working
  // await user
  //   .createDM()
  //   .then(dmChannel => dmChannel.send({ embeds: [embed], files: [attachment] }))
  //   .catch(err => console.error(err))
}

async function generateImage(
  guild: Guild | null,
  channel: TextBasedChannel | null,
  message: Message,
  reply: Message | null
) {
  const canvas = createCanvas(1500, 1000)
  const ctx = canvas.getContext("2d")

  const padding = 50
  const imageSize = 130
  const headerHeight = 100

  // Background
  ctx.fillStyle = Color.DiscordGrey
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  // Guild/channel header
  if (guild && channel && channel.type == ChannelType.GuildText) {
    const guildImageSize = 80
    const guildImagePadding = (headerHeight - guildImageSize) / 2

    headerText(ctx)
    const guildNameWidth = ctx.measureText(guild.name).width
    const channelNameWidth = ctx.measureText(`#${channel.name}`).width

    const headerWidth = canvas.width
    const headerContentWidth = guildImageSize + guildImagePadding + guildNameWidth + padding + channelNameWidth
    const headerPadding = (headerWidth - headerContentWidth) / 2

    // Header background
    ctx.fillStyle = Color.DiscordGreyDark
    ctx.fillRect(0, 0, canvas.width, headerHeight)

    // Header guild image
    ctx.beginPath()
    ctx.arc(
      headerPadding + guildImageSize / 2,
      guildImagePadding + guildImageSize / 2,
      guildImageSize / 2,
      0,
      Math.PI * 2,
      true
    )
    ctx.closePath()
    ctx.save()
    ctx.clip()

    ctx.fillStyle = Color.DiscordGreyDarker
    ctx.fillRect(headerPadding, guildImagePadding, guildImageSize, guildImageSize)

    headerGuildImageText(ctx)
    ctx.fillText(
      guild.name.charAt(0).toUpperCase(),
      headerPadding + guildImageSize / 2,
      guildImagePadding + guildImageSize / 2
    )

    const guildIcon = guild.iconURL({ extension: "jpg" })
    if (guildIcon) {
      const image = await loadImage(guildIcon)
      ctx.drawImage(image, headerPadding, guildImagePadding, guildImageSize, guildImageSize)
    }

    ctx.restore()

    // Header text
    headerText(ctx)
    ctx.fillText(guild.name, headerPadding + guildImageSize + guildImagePadding, headerHeight / 2)
    headerText(ctx, true)
    ctx.fillText(
      `#${channel.name}`,
      headerPadding + guildImageSize + guildImagePadding + guildNameWidth + padding,
      headerHeight / 2
    )
  }

  // Calculate text content
  messageContentText(ctx)
  const lines = separateMessageContent(message.content, ctx, canvas.width - padding * 3 - imageSize)
  const lineHeight = 60
  const replyHeight = reply ? lineHeight : 0
  const contentHeight = lines.length * lineHeight + replyHeight

  const contentSpaceHeight = canvas.height - headerHeight - padding * 2
  const contentMarginTop = headerHeight + padding + (contentSpaceHeight - contentHeight - lineHeight) / 2

  // Reply message
  if (reply) {
    const replyAvatarSize = 50
    const replyUsernamePadding = 8
    const replyLineOffset = 8
    const replyLineArcHeight = 8
    const replyLineForcedExtraHeight = 3

    // Reply line
    ctx.lineWidth = 6
    ctx.strokeStyle = Color.DiscordGreyLight
    ctx.beginPath()
    ctx.moveTo(padding + imageSize / 2, contentMarginTop + replyHeight - replyLineOffset)
    ctx.arcTo(
      padding + imageSize / 2,
      contentMarginTop + replyHeight / 2 - replyLineForcedExtraHeight,
      padding + imageSize + padding - replyLineOffset,
      contentMarginTop + replyHeight / 2 - replyLineForcedExtraHeight,
      Math.sqrt(replyLineArcHeight ** 2 + replyLineArcHeight ** 2)
    )
    ctx.lineTo(
      padding + imageSize + padding - replyLineOffset,
      contentMarginTop + replyHeight / 2 - replyLineForcedExtraHeight
    )
    ctx.stroke()

    // Reply avatar
    ctx.beginPath()
    ctx.arc(
      padding + imageSize + padding + replyAvatarSize / 2,
      contentMarginTop + replyAvatarSize / 2,
      replyAvatarSize / 2,
      0,
      Math.PI * 2,
      true
    )
    ctx.closePath()
    ctx.save()
    ctx.clip()

    const replyAvatar = await loadImage(message.author.displayAvatarURL({ extension: "jpg" }))
    ctx.drawImage(replyAvatar, padding + imageSize + padding, contentMarginTop, replyAvatarSize, replyAvatarSize)

    ctx.restore()

    // Reply username
    replyUsernameText(ctx, reply.member)
    ctx.fillText(
      reply.author.displayName,
      padding + imageSize + padding + replyAvatarSize + replyUsernamePadding,
      contentMarginTop
    )

    const usernameWidth = ctx.measureText(reply.author.displayName).width

    // Reply message content
    ctx.beginPath()
    ctx.rect(
      padding + imageSize + padding + replyAvatarSize + usernameWidth + replyUsernamePadding * 2,
      contentMarginTop,
      canvas.width - (padding * 3 + imageSize + replyAvatarSize + usernameWidth + replyUsernamePadding * 2),
      lineHeight
    )
    ctx.closePath()
    ctx.save()
    ctx.clip()

    replyContentText(ctx)
    ctx.fillText(
      reply.content,
      padding + imageSize + padding + replyAvatarSize + usernameWidth + replyUsernamePadding * 2,
      contentMarginTop
    )

    ctx.restore()

    // TODO: Add edited indicator
  }

  // Avatar
  ctx.beginPath()
  ctx.arc(padding + imageSize / 2, contentMarginTop + replyHeight + imageSize / 2, imageSize / 2, 0, Math.PI * 2, true)
  ctx.closePath()
  ctx.save()
  ctx.clip()

  const image = await loadImage(message.author.displayAvatarURL({ extension: "jpg" }))
  ctx.drawImage(image, padding, contentMarginTop + replyHeight, imageSize, imageSize)

  ctx.restore()

  // Username
  usernameText(ctx, message.member)
  ctx.fillText(message.author.displayName, padding + imageSize + padding, contentMarginTop + replyHeight)

  const usernameWidth = ctx.measureText(message.author.displayName).width
  const usernamePadding = 25

  // Date
  messageDateText(ctx)
  ctx.fillText(
    moment(message.createdAt).format("DD/MM/YYYY HH:mm"),
    padding + imageSize + padding + usernameWidth + usernamePadding,
    contentMarginTop + replyHeight + 5
  )

  // Message content
  messageContentText(ctx)
  lines.forEach((line, index) => {
    ctx.fillText(line, padding + imageSize + padding, contentMarginTop + replyHeight + lineHeight + index * lineHeight)
  })

  // TODO: Add edited indicator

  // TODO: Display images

  // TODO: Display starting frame of video (?)

  // TODO: Display stickers

  // TODO: Display embeds

  // TODO: Display emojis

  // TODO: Display reactions

  // TODO: Format markdown

  // TODO: Little un-obtrusive watermark at the bottom?

  return canvas.toBuffer("image/jpeg", { quality: 1 })
}

function separateMessageContent(content: string, ctx: CanvasRenderingContext2D, maxWidth: number) {
  const words = content.split(" ")
  const lines: string[] = []

  let currentLine = ""
  for (const word of words) {
    if (ctx.measureText(currentLine + word).width >= maxWidth) {
      lines.push(currentLine)
      currentLine = word + " "
    } else {
      currentLine += word + " "
    }
  }
  lines.push(currentLine)
  return lines
}

// Ideas:
// - Allow screenshotting to include the message being replied to
// - Allow screenshotting to include the recent messages prior to it (what amount?)
